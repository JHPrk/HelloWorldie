# 마이크로벤치마킹과 통계

작은 자바 코드 한 조각의 성능을 정확히 측정하는 것은 매우 미묘하고 어려운 일

마이크로벤치마킹 툴의 업계 표준 : **JMH(Java Microbenchmark Harness)**

## 자바 성능 측정 기초

**마이크로벤치마크는 웬만하면 안하는게 좋다.**

1. 왜? JVM의 고도화된 코드 최적화 때문에

- JIT컴파일을 통해 최적화하려면 일정기간 웜업이 필요함
- 조금이라도 효율적으로 동작하기 위해 호출 계층을 최적화하여 캡쳐 타이밍에 따라 결과가 달라짐
- 같은코드를 너무 많이 반복 호출하면 루프 최적화가 적용되어 코드 실행시간이 달라짐
- 코드로는 작성하였지만 실제로 실행에 큰 의미가 없거나 결과값을 사용하지 않는 등 JVM이 판단하기에 코드 실행이 필요없다고 생각하면 작성된 코드를 무시하고 실행되는 경우가 있음

2. 왜? GC의 실행이 예측불가능하기 때문에

그래서 거시적으로 바라보고 예측 불가능한 것을 제거하여 CPU 사용률 등을 바라보는것이 더 효과적일때가 많지만 마이크로벤치마크를 해야하는 경우가 있음

- 사용 범위가 넓은 범용 라이브러리를 개발할 때
- OpenJDK 또는 다른 자바 플랫폼 구현체를 구현할 때
- 지연에 극도로 민감한 코드를 구현해야할 때.(결제 등)

따라서 위 사항이 필요없는 일반 개발자의 경우 마이크벤치마크를 해야하는가 진지하게 고민할 필요가 있음.

**그러면 어떻게 해야하는가?**

- 시스템 전체를 벤치마크하고 저수준 수치는 수집하지 않거나 무시
- 연관된 저수준의 결과를 의미있게 비교하기 위해 공통 프레임워크를 통해 처리

### 조심해야할 상황

아무 의미가 없더라도 항상 어떤 수치가 만들어지는데, 그 실체가 확실치 않을때가 많음

따라서 마이크로 벤치마크는 극단적인 어플리케이션에 한하여 사용하는 것이 좋다.

## JMH 프레임워크

자바를 비롯해 JVM을 타깃으로 하는 언어로 작성되어 나노, 마이크로, 밀리, 매크로 벤치마크를 제작, 실행, 분석하는 자바 도구이다.

JVM을 빌드하는 사람들이 직접 만든 프레임워크라 툴 사용법만 알면 베어트랩에 빠질일 없이 안전하다.

벤치마크 코드에 애너테이션을 붙여 자바 소스를 추가 생성하는 식으로 작동 (@benchmark)

상태 제어하는 애너테이션 제공

- @State가 달려있으면 벤치마크 도중에 엑세스 할 수 있음.
- Benchmark, Group, Thread 세 상태가 정의된 Scope 이넘을 받음
- JVM의 최적화를 방지하도록 모든 결과값을 JMH 개발자가 정의한 블랙홀에 할당함
    - 메서드 내에서 코드가 부수 효과를 일으키지 않고 결과를 사용하지 않을 경우 삭제하는 것을 방지

### 블랙홀

- 벤치마크에 영향을 줄 수 있는 최적화로부터 코드를 보호.
- 스코프가 한정된 탓에 벤치마크가 과최적화 되지 않도록 함.
- 잘 쓰려면 무엇보다 JIT컴파일러를 자세히 잘 알고있어야함.
1. 런타임에 죽은 코드를 제거하는 최적화를 못 하게 한다.
2. 반복되는 계산을 상수 폴딩 하지 않게 만든다.
3. 값을 읽거나 쓰는 행위가 현재 캐시 라인에 영향을 끼치는 잘못된 공유 현상을 방지.
4. 쓰기 장벽으로부터 보호 
(리소스가 포화되어 병목을 초래하는 지점. 쓰기 장벽의 경우 캐시에 영향을 미치고 쓰기 버퍼가 오염)

컴파일러는 똑똑해서

- 분기에 대해 탈출 분석을 해보고 이 객체가 어느 객체와도 동등할 수 없다고 결론 내리면 비교문 자체가 return false; 하나로 최적화 되기도 함.
- 그래서 이를 우회하기 위해 아주 드문 경우에만 실행되는 조건을 만들자.

## JVM 성능 동계

### 오차 유형

랜덤 오차(random error)

- 측정 오차 또는 무관계 요인이 상관관계 없이 영향을 미침
- 정밀도는 랜덤 오차의 수준을 나타냄. (높은 정밀도 → 낮은 랜덤 오차)
- 랜덤 오차는 원인을 알 수 없는, 또는 예기치 않은 환경상의 변화 때문에 일어남
- 소프트웨어에서는 측정 툴을 못 믿을 이유가 없으므로 근원은 오직 운영 환경 뿐
    - 주의사항 : 오차는 가우시안 분포를 따르지 않음. (오차가 측정값에 미치는 긍정적/부정적 영향도가 얼추 비슷하지 않기 때문)

계통 오차(systematic error)

- 원인을 알 수 없는 요인이 상관관계가 있는 형태로 측정에 영향을 미침
- 정확도는 계통 오차의 수준을 나타냄. (높은 정확도 → 낮은 계통 오차)

### 허위 상관

- 상관 관계는 인과를 나타내지 않는다.
    - 두 변수가 비슷하게 움직인다고 해서 직접적인 연결고리가 있다고 볼 수 없음.
    - ex) 원유 수입량과 치킨 소비량, 비디오 아케이드 게임 매출액과 컴퓨터 과학 박사 학위 수여자
- JVM과 성능 분석 영역에서는 그럴싸해 보이는 연결고리와 상관관계만 보고 측정값 간의 인과관계를 넘겨짚지 말자.

자바 성능 통계학은 비정규 분포를 따른다.

- JVM은 JIT컴파일 최적화를 통해 빠른건 더욱 더 빠르게하는 핫 패스가 있음
- JVM의 여러 최적화 기법이 적용되어 빠른 성능을 보이는 코드가 엄청 많고 문제 있는 곳은 느린 긴 꼬리형 비정규 분포를 다룸
- GC의 예측 불가능한 실행 시기 및 실행 시간 (모든 어플리케이션이 멈춤)

[HdrHistogram](https://github.com/HdrHistogram/HdrHistogram) 으로 GC수집을 히스토그램화 해보자.

## 통계치 해석

애플리케이션을 측정하여 얻은 결과값을 해석하는게 제일 힘들고 어려움

[Paypal 모자/코끼리 문제 (155p)](https://medium.com/paypal-tech/statistics-for-software-e395ca08005d)

[Programming Links.md](https://github.com/DevNambi/blog-drafts/blob/master/9900%20-%20Programming%20Links.md) 참고

## 마이크로벤치마킹을 측정할때 주의사항

1. 유스케이스를 확실히 모르는 상황에서 사용 금지
2. 그래도 마이크로벤치마킹 해야하면 JMH 이용
3. 얻을 결과를 가능한 한 많은 사람과 공유하고 동료들과 의논하기
4. 항상 잘못된 가능성을 염두에 두고 생각을 지속적으로 검증해야함

## 마이크로벤치마킹의 장점

- 저수준 서브시스템들이 유발한 고도로 동적인 움직임과 비정규 분포 양상을 명확히 드러냄
- JVM의 복잡성을 머리속에 정리하고 이해하는데 도움이 됨