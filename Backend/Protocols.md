# Protocols

# IP

- Internet Protocols의 약자
- 패킷으로 나뉘어져서 전송됨 (MTU에 따라 나뉘어질 수 있다.)
- Network Layer(3)에서 동작
- DNS가 도메인을 입력하면 IP Address로 매핑시켜줌
    - IP하나에 여러 서버가 동작할 수 있음!
    - 하나의 아이피당 10개의 서버가 동작 가능하고 DNS서버가 식별 가능
- IP패킷은 20바이트의 헤더가 있음
    - 여기에는 congestion control, protocols에 대한 기본 정보들이 있음
    - 그리고 옵션을 주면 60바이트까지 늘어날 수 있음

# UDP

- User Datagram Protocol
- 단방향 통신이고 데이터 전송여부에 대해 보장하지 않음
- Transport Layer(4)에서 동작
- 안전하지 않은 연결
- 딱 간단하게 연결만 지원하고 딱 치고 빠지는 느낌
- TCP처럼 핸드쉐이크 과정이 없고 딱 데이터만 전송하고 데이터가 정상적으로 전달되었는지 여부도 판단안하기 때문에 빠름
- 헤더도 8바이트로 딱 source port, target port, data length, checksum으로만 이루어짐

# TCP

- Transmission Control Protocol
- 커널에서 연결을 수행하는 3-Way Handshake과정이 있음
- Statful 커넥션임
- Transport Layer(4)에서 동작
- 연결을 맺기 위해 SYN을 보내고 서버는 ACK/SYN을 다시 클라이언트로 보내고 클라이언트는 마지막으로 ACK를 보내면 됨
- 서로에 대한 연결 정보는 fd(파일 디스크립터)로 관리됨
- 연결이 끝나면 FIN요청을 보내서 연결을 종료
- HTTP가 TCP위에서 동작함
- 20바이트 헤더
    - 옵션에 따라 60바이트까지 늘어날 수 있음
    - Congestion 컨트롤을 지원 (혼잡도 표시가능)
    - SYN, ACK, FIN등을 위한 플래그 비트 9개

# TLS

- Transport Layer Security
- Transport Layer(4)에서 동작
- SSH 연결의 핵심
- 보안을 책임진다
- 보안을 위해서 요청 및 응답을 암호화할 필요가 있음
- 이를 위해 암호화 키가 필요한데 대칭 키와 비대칭 키가 있음
    - 가장 간단한 암호화는 XOR 연산으로 키와 대조하는 것
    - 비대칭 키는 높은 보안성을 가지고 있지만 그만큼 자원이 많이 소모
- 대칭키가 제일 빠른데, 관건은 서버와 클라이언트가 서로 동일한 키를 공유해야하나 이를 직접적으로 키를 전송하면 안된다는 문제를 해결해야함
- 대칭키 전송 방식
    - RSA
        - public key / private key 를 이용한다.
            - public key로 암호화한 데이터는 private key로만 복호화가 가능함
        - public key를 클라이언트에 전송
        - 클라이언트는 대칭키로 사용할 자신의 키를 서버로 부터 받은 public key를 이용해서 암호화 한 뒤 서버에게 전송
        - 서버는 public key로 암호화된 클라이언트 키를 private key로 복호화하여 서로 공유하는 대칭키를 얻음
        - 그러나 서버의 private key를 탈취할 수 있는 RSA취약점이 발견되었음
    - Deffie Helman 알고리즘
        - (x^a % n)^b = (x^b % n)^a = (x^ab % n) 과 같다는 걸 이용함 (단, 여기서 a,b는 소수여야함)
        - 클라이언트와 서버는 각각 a,b에 해당하는 private 키를 가지고 있음
        - 그래서 먼저 클라이언트가 공개키 x와 공개키를 클라이언트가 가지고 있는 private 키 a로 암호화한 키(x^a % n)를 서버에 전송
        - 서버는 이 데이터를 받아서 공개키 x를 서버가  가지고 있는 private 키 b로 암호화한 키(x^b % n)를 서버에 전송
            - 또한 서버가 받은 (x^a % n)는 서버가 가지고 있는 private 키 b를 지수연산하여 (x^ab % n)이라는 키를 만들어냄
        - 클라이언트는 서버로 부터 받은 (xb % n)를 클라이언트가 가지고 있는 private 키 a를 지수연산하여 (x^ab % n)이라는 키를 만들어냄
            - 서로 대칭키를 얻었음!
- TLS는 1.2, 1.3이있고 0RTT(Round Trip)을 위한 방법론도 존재함.

# HTTP/1.1

- HTTP/1.0은 기본적으로 단방향 통신이고 TCP연결을 하고 하나의 요청을 응답하면 그 즉시 그 연결을 끊어버리는 특징이 있었음
    - 커넥션 생성 비용이 꽤 크기때문에, 한번 연결한 다음에 이를 재사용할 필요성이 생김
- 따라서 HTTP/1.1이 등장
    - 연결이 바로 끊기지 않는다는 특징이 있음
    - 그러나 sequential하게 동작한다는 특징이 있음
        - 즉 요청이 3개가 일어나면 먼저 일어난 요청이 반환되어야지만 이후 요청을 반환할 수 있음
        - 파이프라인을 3개 만들면 가능하긴 함.
    - 요청 - 응답에 대한 파이프라인이 1:1 대응
        - 즉 단일 요청이 끝나기 전에는 해당 파이프라인에 다른요청을 보낼 수 없음
- 브라우저 마다 다르긴 하지만 단일 도메인에 대해 HTTP/1.1 파이프라인은 최대 6개까지 만 생성 가능
    - 크롬에서 그렇게 설정하였음
- 헤더, body가 따로 존재하며 각각 다르게 암호화 됨.
- 데이터 패킷에는 시퀀스가 있으며 각 데이터 패킷은 MTU에 따라 나뉘어저 보내지게 된다.

# Web Socket

- 웹 소켓은 기본적으로 HTTP 요청으로 이루어 지다가 특수한 요청 (ws:// or wss://) 을 통해 HTTP연결을 웹소켓으로 변경이 가능함
    - 이때 protocol change라는 101응답이 사용됨
- 웹소켓이 생성되면 서로 데이터를 주고받는 양방향 통신이 가능함
- TCP연결은 오랫동안 사용안하면 끊어진다는 특징이 있어서 웹소켓은 끊임없이 헬스체크를 시도해서 연결이 살아있음을 증명함

# HTTP/2

- HTTP/2는 HTTP/1.1이 하나의 요청에 하나의 파이프라인만 매핑이 가능하고, 한번에 최대 6개의 연결만 열 수 있다는 단점이 있는 것을 개선
- HTTP/2는 스트림을 이용해서 하나의 연결 파이프라인에 대해 여러 요청을 한번에 보낼 수 있음
- Stream id로 관리되는데 특이사항으로는 클라이언트단에서의 stream id는 홀수번호로 매겨짐 - 1,3,5,7
    - 그러면 서버에서 보내는 응답은 짝수 2,4,6,8이 각각 대응되는 응답 id
- HTTP/2에는 한번의 요청에 필요하다고 생각하는 여러개의 리소스를 한번에 push하는 컨셉트가 도입되었는데 이건 완전 실패된 기능임
    - 왜? 클라이언트가 필요없다고 생각하는 데이터도 일방적으로 푸시하기 때문
- HTTP/2에는 치명적인 약점이 있음
    - 스트림 아이디를 부여하고 이를 병렬로 처리한다는 관점은 모두 Application레이어에서 처리하게 되어 복잡해짐
    - 즉 결과적으로 TCP를 기반으로 작동하기 때문에, TCP의 특징을 그대로 물려받고 있음
    - 먼저 스트림으로 나뉘어져서 요청이 여러개 있어도 결국 데이터 패킷은 순서가 보장되어야 해서 패킷중에 하나라도 제대로 받지 못하면 서로 다른 요청이라도 이를 하위레이어에선 구분이 불가하기 때문에 모두 폐기되게됨
- HTTP/2가 header를 압축하는 알고리즘인 Hpack에서 쿠키를 유추할 수 있는 약점이 있음 이를 (Compression Ratio Info-leak Made Easy)라고 함.
    - 압축 알고리즘의 취약점으로 cookie가 매핑된 지점이 일정하다는 점을 이용
- gRPC가 HTTP/2기반으로 작동함
- 더 많은 CPU와 메모리가 필요(스트림 id도 관리해야하기 때문 - congestion control도 필요)

# HTTP/3

- TCP기반이고 애초에 단일 요청에 대해서만 고려하여 설계되었기 때문에 TCP기반으로 동작하는 HTTP/2는 제약이 많을 수 밖에 없었음
    - Stream Id를 애플리케이션단에서 관리하게 되어서 Congestion Control, Flow등 애플리케이션단에서 처리해야하는 의무가 많아졌음
- 따라서 TCP를 대체하고 스트림에 특화된 별도의 L4의 프로토콜을 만듦
    - QUIC 위에서 동작하는 HTTP/3 프로토콜임
- HTTP/3는 기존 HTTP/2에서 문제가 되었던 순서대로 패킷을 받야아한다는 제약을 없애버림
- QUIC은 UDP에서 Stream Congestion 컨트롤을 추가한 것으로 빠르다는 점이 있음
    - UDP환경에서 Stream을 구분하기 위해 Connection ID를 부여하여 구분함
- Connection ID를 추가하여 연결을 구분하는건 사용자의 IP가 바뀌어도 커넥션을 유지할 수 있다는 장점이 있음
    - TCP는 IP가 바뀌면 새로 핸드쉐이크해서 연결을 만들어야함.
- 단 보안은 떨어지게된다. 왜? Connection ID는 암호화되는 정보가 아니기 때문.
- Stream ID를 Connection ID를 통해 순서를 재조립해야하기 때문에 더 많은 시스템 리소스가 필요.

# gRPC

- google Remote Procedure Call (원격 프로시져 호출)
- 전세계적으로 인기있는 프로토콜
- 프로토콜은 각 사용처마다 어떻게 동작하는지, 어떻게 해석되어야하고 실행되어야하는지에 대한 규약이고 약속이다.
- 그러나 문제는 프로토콜이 너무 많다는 점!!
    - 실시간 통신을 하고 싶으면 websocket, SSE, HTTP, UDP, Long-polling등 용도에 맞게 설치해야하는 라이브러리가 너무 다양함
- 이를 잘 실행하려면 클라이언트도, 서버도 각 프로토콜에 대해 처리할 수 있어야함
    - 그리고 프로토콜을 지원하기 위해 지원이 필요한 프로토콜에 대해 따로 라이브라리를 임포트하고 개발해야하는 단점이 있음
- 따라서 구글에서 프로토콜을 통합하기 위해서 Protocol buffer를 이용해 대통합을 시도함
- Protocol Buffer에 Schema를 정의하고 여기에 따라 서버가 제공하는 모든 서비스들을 제공
- 각 언어로 컴파일되고 프로토콜을 정의하는 언어를 두어 호환성이 높음
    - HTTP/2를 기반으로 만들어져 있음
    - HTTP/2는 애플리케이션 단에서 처리해야하는 요소들이 많은데 이를 다 gRPC가 내부적으로 처리해준다는 점도 매력적임.
- 다만 하나로 모든걸 다 처리하다보니 너무 무겁고 스키마를 정의하기 위한 언어를 따로 배워야한다는 러닝커브가 있음.

# web-RTC

- 오디오나 비디오같은 낮은 레이턴시로 효율적으로 전송하는 Peer-2-Peer 연결
- Web Real Time Communication
- 가장 낮은 레이턴시로 직접 연결
- RTC를 자세히 이해하려면 NAT에 대해서 알아야함.
- 오픈소스 프로젝트
- NAT는 Network Address Tranlastion
    - 인터넷에 연결된 장치는 private IP와 public IP가 있음
    - 그러나 WiFi나 LAN같은 경우에는 한 기기당 하나의 public IP가 있지 않음
        - 라우터가 public ip를 갖고 있음
    - 패킷을 서버에 보낼때 패킷을 구성하는데.. 자신의 IP와 타겟 IP를 요청
        - 그러나 타겟 IP가 자신의 서브넷에 없으면 게이트웨이에게 해당 서버를 연결해달라고 요청함
        - 다른 라우터에게 해당 서버를 찾아달라고 패킷을 보내야하는데 자신의 private IP를 소스에 넣으면 다른 라우터가 이걸 찾을수가 없음
        - 따라서 다른 라우터에게 요청하기 전에 소스 IP를 라우터의 공용 IP로 덮어쓰고 port와 IP의 정보를 테이블화 해서 관리함
    - 패킷이 타겟 서버에 도달하면 응답을 주게 되는데, 응답을 줄때 요청받은 라우터의 공용 IP와 포에게 보내게됨
        - 최종적으로 패킷이 원래 라우터에 그때 구축해놨던 내부 IP와 매핑함
    - NAT가 동작하는 방법은 크게 4가지가 있음
        - One to One NAT (Full-cone NAT)
            - 한번 성립된 공용 IP + 공용 포트가 있으면 들어오는 패킷의 소스가 어떤것이든 다 연결시켜줌
        - Address restricted NAT
            - 적어도 한번이라도 연결된 외부 서버 아이피여야지만 연결시켜줌
        - Port restricted NAT
            - 한번이라도 연결된 외부 서버 + 포트여야지만 연결시켜줌
        - Symmetric NAT
            - 무조건 1:1관계만 성립함. 인터널 IP + port 와 Dest IP + port관계에서만 패킷이 허용됨
            - Symmetric NAT의 경우 제약이 많아서.. STUN 방식 불가 → TURN사용해야함
        - 아래로 갈수록 제약이 큼
- STUN, TURN
    - STUN - Session Traversal Utilities
        - 내 자신의 NAT 테이블과 web-RTC연결을 할 대상 서버의 NAT를 연결시켜주는 역할
        - 3478 포트에서 주로 동작, 5349는 TLS
        - 유지보수 비용이 가벼움
        - STUN 서버에 요청을 보내고 응답을 받으면 NAT 테이블에 등록되는 거임
        - 연결할 a,b모두 STUN서버에 요청 및 응답을 받고, Symmetric NAT가 아니면 서로의 서버에 직접적인 연결이 가능해지는 것!
    - TURN - Traversal Using Relays around NAT
        - Symmetric NAT에는 동작하지 않기 때문에 우회가 필요함
        - Peer 2 Peer가 불가능하여서 중간에 STUN역할하는 서버가 중개까지 해줌
        - 서버의 유지보수 비용이 많이 들어감
- ICE - Interactive Connectivity Estabilishment
    - RTC연결을 할 수 있는 모든 후보군들을 모아놓음
        - private, public reflexive IP
        - 이러한 ICE가 모여서 SDP가 됨
- SDP (Session Description Protocol)
    - ice 후보들, 네트워크 옵션, 미디어 옵션, 보안 옵션 등 여러가지를 기술
    - 이건 프로토콜은 아니구 그냥 포맷임 텍스트형식
    - WebRTC에서 가장 중요한 요소
- Signaling the SDP
    - 이렇게 만든 SDP를 상대방에게 전송하는 것
    - 이 SDP를 어떠한 방식으로던 연결할 상대에 전달해야함
        - QR이던, 왓츠앱이던, 웹소켓이든 상관없음

## WebRTC 동작 방식

1. A가 B에게 연결하고 싶음
2. A는 제안(offer)을 만듦. 모든 ICE 후보들을 탐색. 보안 옵션, audio/video 옵션을 정하고 SDP를 만듦
3. B에게 어떠한 방식으로든 SDP를 전달
4. B는 A의 오퍼(SDP)를 받고 답변(Answer)을 생성
5. B는 답변(SDP)를 A에게 전달
6. 커넥션이 만들어짐