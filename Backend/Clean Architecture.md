# Clean Architecture란?

![image.png](Clean%20Architecture/image.png)

- 소프트웨어를 관심사를 기준으로 레이어로 나누는 것
- 의존성을 오직 내부를 가르키도록 해서 달성할 수 있음
    - 이를 Dependency Inversion과 다형성을 이용해 달성 가능
- 외부 요소와 독립적이고 쉽게 테스트할 수 있는 소프트웨어 가질 수 있음.
    - 프레임워크, UI, Database 등 외부 에이전트와 독립적임
    - 도메인을 외부 의존성 없이 테스트 가능
- 도메인 로직에 대한 유스케이스와 엔티티를 정의
    - 엔티티 → 로메인 단에서의 크리티컬 비지니스 로직
    - 유스케이스 → 애플리케이션 단에서의 크리티컬한 비지니스 로직
- 결국 클린 아키텍쳐는 핵사고널 아키텍쳐의 개념을 포함함(onion architecture)
- 도메인레이어를 격리하고 독립적으로 만들어 안정적으로 만드는것이 주 목표
- 다른 모든것들은 도메인 레이어에 대해 교체가능한 플러그인 일 뿐

# Hexagonal Architecture

![image.png](Clean%20Architecture/image%201.png)

- 핵사고널 아키텍쳐는 Ports와 Adapters라고도 함
- 주요 아이디어는 소프트웨어를 내부(도메인 레이어)와 외부(인프라 레이어)로 나누는 것임
    - 내부(도메인)먼저 구현하며, 프레임워크 데이터레이어 UI와 같은 다른 레이어에 의존하지 않을 것.
- 핵심 원칙은 도메인을 모든 종속성에서 분리, 고립시키는 것
    - 외부 부품은 소프트웨어가 아닌 소프트웨어의 대한 플러그인으로 작동해야함
- 인프라에서 격리된 비즈니스 로직은 쉽게 테스트가능한 애플리케이션으로 끝남
- 2005년 Alistair Cockburn이 발명함
    - 애플리케이션이 유저와 프로그램, 자동화된 테스트 또는 브랜치 스크립트들에게 동등하게 다뤄져야 하며 런타임 장치나 데이터베이스로부터 분리되어 개발 및 테스트되어야 함.
- Adapter는 두가지 종류가 있음
    - 어댑터는 교체 가능한 구성 요소이다.
    - Primary 어답터는 도메인 계층에 있는 핵심 논리를 사용
        - Input Port를 사용해 도메인 계층에 정의된 유스케이스를 호출
    - Secondary 어답터는 데이터베이스 또는 메시지 큐와 같은 외부 태스크를 호출
        - Output Port를 사용해 비니지스 로직으로 처리된 것을 외부 인프라에게 호출
- 사용자의 입력은 하나 이상의 Pirmary 어댑터에 의해 처리되고 핵심 코어 로직으로 전달됨.
- 코어 로직은 Secondary 어답터와 상호작용함
- 핵심 코어 로직의 출력은 다시 Primary 어답터를 사용해 사용자에게 반환된다.
- 특징은 모든 입력과 출력에 인터페이스를 사용
- 통합 및 Dependency Injection(종속성 주입)을 통해 런타임에서 어답터의 구현이 정해짐

![image.png](Clean%20Architecture/image%202.png)

- 장점
    - 계속 요구사항이 변화하는 애플리케이션에 유용하다. 항상 새로운 기술 변화에 대응할 수 있다는 장점
    - 기술적인 변경사항은 비즈니스 로직에 전혀 영향을 미치지 않음
        - ex) 데이터 베이스를 쉽게 바꾸거나 적용할 수 있음
    - 기존 레이어 아키텍쳐를 개선한 구조로 모든 종속성이 안쪽을 향하게 함. 모든 종속성은 비즈니스 로직을 위한 플러그인이 된다. 내부에서 외부로의 관계가 필요하면 포트나 어답터를 이용하도록 함.
    - 모든 종속성이 비즈니스 계층을 가르켜 비즈니스 계층을 독립적으로 만듦.
- 포트나 어답터가 어떻게 종속성을 반전하고 비즈니스 로직을 독립하는지 보여줄 것.
    - DI와 다형성을 이용하면 쉽게 반전가능
- 클린 아키텍쳐를 사용하면 모든 종속성의 구현 결정을 지연할 수 있음
- 데이터소스나 프레임워크의 제한 사항을 고려하지 않고 논리를 구현 가능.
    - 외부 종속성이 결정 안나면 이를 mocking해서 비즈니스 로직을 완전히 테스트 가능함
    - 또한 비즈니스 로직을 건들이지 않고 어답터를 쉽게 교체할 수 있음
- 다른 레이어에 영향을 주지 않고 각 레이어를 별도로 유지 가능
- 따라서 한 모듈의 변화가 다른 모듈에 영향을 끼치지 않으니 유지보수도 쉬워짐
- 그리고 레이어가 분리되었기 때문에 자연스럽게 이해하기 더 쉬워짐.
- 각 파트별로 배포 원칙이나 개발을 다르게 설정 가능.
    - 규칙을 지키는 것은 어렵지 않으며 많은 골칫거리를 줄여줄 것.

모든 아키텍쳐는 장/단점이 있다.

- 단점
    - 더 많은 코드를 작성해야함 또한
    - 일부 코드를 복제해야 하는 경우가 많음
        - 데이터를 보내기 위해 데이터 전송 오브젝트를 만든다던가..

## Entity

- 각영역의 핵심 비지니스 로직을 나타내는 오브젝트
    - 주문생성하기 전에 주문상태를 확인, 가격이 정확하거나와 같이 중요한 규칙 설정

## Use Cases

- Entity위의 계층으로 애플리케이션에 특화된 비지니스 로직 규칙들
- 엔티티를 올바른 순서로 호출하여 엔티티를 조율하고 핵심 비즈니스 로직을 달성함
- 데이터의 흐름을 오케스트레이션을 수행, 엔티티로가 제공하는 핵심 비즈니스 로직을 이용해 애플리케이션단의 유스 케이스를 달성
    - ex) 일시적인 할인이라던가.. 사용자가 일일 구매 허용량을 초과하는지 체크한다던가..
