# 성능 테스트 및 안티패턴

성능 테스트는 중요하지만 나쁜 의도나 부실하게 수행하는 경우가 많음

어떤 성능을 측정할지, 목표를 정하지 않고 진행하는 것은 좋지 않다.

## 성능 테스트 유형

테스트는 유형별로 목표가 거의 독립적이고, 어떤 테스트를 하더라도 도메인을 심사숙고해야함.

좋은 성능 테스트는 정량적이다. 실험 결과를 토대로 수치화한 답변을 내놓을 수 있어야 한다.

### 일반적인 성능테스트

1. **지연 테스트(Latency test)**
종단 트랜잭션에 걸리는 시간?  
가장 일반적인 테스트 → 유저 경험과 직접적인 연관이 있음  
그러나 너무 매몰되면 안됨. 다른 측정 테스트도 중요  
그러나 평균 응답값은 의미가 없음  
2. **처리율 테스트(Throughput test)**  
처리 가능한 동시 트랜잭션 개수  
그 다음으로 일반적인 테스트  
시스템 지연을 측정할때 반드시 처리율을 얼마정도 유지했는지 확인 필요  
지연 분포가 갑자기 변하면 이게 시스템의 한계점(변곡점)이다.  
3. **부하 테스트(Load test)**  
특정 부하를 시스템이 감당 가능한가?  
처리율 테스트랑은 다름. 이정도 부하를 견딜 수 있을까?  
4. **스트레스 테스트(Stress test)**  
시스템의 한계점은 어디까지인가?  
시스템 여력이 어느정도일까?  
최대치의 처리율을 계속 걸어두면 서서히 측정값이 나빠지는 시점 측정  
5. **내구성 테스트(Endurance test)**  
장기간 실행할 경우 이상증상?  
메모리 누수, 캐시 오염, 메모리 단편화 등 한참뒤에나 감지할 수 있는 문제점 파악  
평균 사용률로 시스템에 일정 부하를 주다가 리소스가 고갈되거나 시스템이 깨지는 지점 파악  
6. **용량 계획 테스트(Capacity Planning test)**  
리소스를 추가한 만큼 시스템이 확장되는가?  
업그레이드 한 시스템이 어느 정도의 부하를 감당할 수 있을지 파악  
스트레스 시스템과 비슷  
7. **저하 테스트(Degradation)**  
시스템이 부분적으로 실패할 경우 어떤 일이 벌어지나?  
부분 실패 테스트라고도 함  
**복원 테스트** - 평상시 운영환경과 동등한 수준의 부하를 주다가 특정 서브 시스템이나 컴포넌트가 능력을 상실하면 벌어지는 일 측정
    - 넷플릭스 카오스 몽키 테스트 : 운영 환경에 있는 리소스를 하나씩 죽이면서 테스트
    - 진짜 복원성 있는 아키텍쳐는 어느 한 컴포넌트가 잘못돼도 다른 컴포넌트까지 연쇄적으로 무너뜨리면서 전체 시스템에 영향이 없어야한다.

### 성능 테스트를 위해 해야하는 것

1. **하향식 성능**  
전체 애플리케이션의 성능 양상을 먼저 알아보는 것이 코드 섹션별로 알아보는 것보다 더 쉽다.  
그래서 탑 다운식으로 (전체 → 세부코드)로 알아보는 것  
2. **테스트 환경 구축**  
성능 테스트 팀이 반드시 해야 하는 것.  
테스트 환경은 가능한 운영 환경과 똑같이 복제해야함.  
서버, 런타임 버전, DB, 로드 밸런서, 방화벽 등.  
3. **성능 요건 식별**  
전체 시스템 성능은 애플리케이션 코드, 컨테이너, OS, 하드웨어 모두 영향을 끼침.  
시스템을 전체적으로 바라보고 최적화하려는 핵심 지표 설정(NFR-성능 비기능 요건)  
**ex)** 95% 백분위 트랜잭션 시간을 100밀리초 줄이기, 처리율 5배 높이기, 고객 이탈률을 25밀리초 지연당 25% 낮춘다 등.  
4. **자바에 특정한 이슈**  
JVM 특유의 자기 관리 기능으로 인해 자바만의 독특한 최적화  
-> JIT 컴파일할 정도로 자주 실행되는 메소드가 아님  
-> 메소드가 너무 크고 복잡해서 컴파일 분석이 불가능  
어떤 메소드가 컴파일중인지 로그를 남겨 핵심 코드 경로에 있는 중요 메소드가 잘 컴파일되고 있는지 확인.  
5. **SDLC 일부로 성능 테스트 수행**  
수준 높은 팀일수록 성능 테스트를 전체 소프트웨어 개발 수명 주기(SDLC)의 일부로 가져간다.  

## 성능 안티 패턴

- 경험론적으로 밝혀낸 소프트웨어적으로나 팀적으로 좋지 않은 패턴들
- 성능 튜닝은 항상 초기 단계부터 구체적인 목표를 정해놓고 시작하는 목표지향형 프로세스로 접근해야 함
- 성능 테스트를 하나도 안했거나 팀에 닌자가 나타나 성능이나 동작 대해 온갖 추정만 하고 사라져버렸기 때문

### 캐리 플리첼의 왜 개발자는 잘못된 선택을 밥먹듯이 하나?

1. **지루함**  
개발자의 지루함으로 증명되지 않은 기술이나 복잡한 알고리즘 제작  
**사례**  
  i. Collections.sort() 한줄로 할 수 있는 정렬을 직접 알고리즘을 구현하여 필요 이상으로 복잡하게 됨  
  ii. 지금까지 알려지지 않은 기술로 컴포넌트 제작  
  iii. 맞지도 않은 유스케이스에 억지로 기술을 욱여 넣음  
  
2. **이력서 부풀리기**  
본인 이력을 부풀리기 위해 불필요한 기술을 덧대거나 사용  
3. **또래 압박**  
팀원들이 기술을 결정할때 관심사를 분명히 밝히지 않고 충분한 논의 없이 진행  
- 가면 증후군(특정 주제에 대해 자기가 잘 모른다는 사실을 밝히는 것을 두려워 함)때문에 논의를 안함
- 경쟁이 치열함 팀 분위기 속에서 개발이 빨리 진행되는 듯 보이고자 섣불리 중요한 결정을 내리는 것
4. **이해 부족**  
지금 사용하는 툴의 기능도 알지 못하는데 무턱대고 새로운 툴로 문제를 해결하려고 해서  
- 이해가 부족한 상태에서 이게 좋다더라 하고 사용하면 문제가 일어났을 때 대처 불가
5. **오해와 있지도 않은 문제**  
문제 자체가 무엇인지 이해하지 못햇는데 오로지 기술을 이용해서 문제를 해결하려는 개발자 때문에  

## 성능 안티 패턴 카탈로그

### 최신의 멋진 기술을 튜닝하려고 할때

- 문제
    - 문서만 보고 지레짐작하면 안됨
    - 그냥 어떻게 해보면 되겠지보다는 애플리케이션을 측정하고 튜닝해야함
    - 온라인 예제는 보통 작은 규모의 데이터셋만 다뤄서 기업 규모로 적합하지 않음
- 진짜 측정을 해보고 성능 병목점을 찾자
- 새 컴포넌트는 전후로 충분한 로그를 남기자
- 팀원들이 새 기술을 이해하도록 독려하고 팀 차원의 베스트 프랙티스 수준을 정하자

### 요약

- 알고있는 부분부터 봄, 성능 측정으로 병목점을 찾아야 된다.
- 갑자기 나타나서 성능을 해결해주는 전문가(히어로)는 없음
    - 팀내 전문가도 결국 성능 측정부터, 프로파일링부터 한다.
- 스택 오버플로 팁은 오래된 정보일 수 있어서 충분히 테스트해봐야함
- 이슈와 전혀 상관없는 특정 컴포넌트를 문제 삼음
    - 충분히 분석 필요
    - 인지편향땜에 성급한 결론
- 극소 부분만 프로파일링해서 정답을 찾으려고 함
    - 이 설정만 조금 바꾸면 어케될까?
    - 변경 영향도를 완전히 이해한 사람이 없어서
- 내 운영 개발 환경과 UAT (로컬 개발 환경)를 맞춰야함 (성능까지)
- 데이터는 운영 데이터처럼 만들어야함 (데이터 라이트라고도 하는 안티패턴)
    - 데이터를 단순화하거나 운영 데이터와 비슷한 데이터를 한꺼번에 넣으면 테스트를 안하는것 보다 못함

## 인지 편향과 성능 테스트

성능 문제를 해결하던 경험으로 인해 무의식적으로 가정을 내림

확증 편향과 최신 편향(최신에 일어난 일이 앞으로도 계속 일어날거라 믿는 것)이 조합된 것임

### 내가 하면 잘돼 안티 패턴

- 내 컴퓨터에서 잘 돌아갔으니 운영계 어딘가가 문제겠지 ㅡㅡ 하는 사고방식
- 코드 말구 인프라가 문제에요~ 하는거

### 환원주의

- 시스템을 작은 조각으로 나누어 그 구성 파트를 이해하면 전체 시스템도 다 이해할 수 있다는 사고방식
- 시스템을 항상 전체로 바라봐야 함

### 확증 편향

- 애플리케이션을 주관적으로 바라보게 함
- 감정이나 동기가 부여됨
    - 최신 기술이 더 좋음을 증명하기 위해 편향을 가지고 접근
    - 일부 테스트만 하고 결론을 내리면 편향 생김

### 행동 편향

- 진짜 급한 상황
    - 시스템이 중단
    - 바쁜데 급한 이슈 생김
    - 엄청 큰 이슈
- 등이 생길때 이걸 어떻게든 해결해야겠다고 해서 일단 행동부터 수행하는거
    - 파드 재실행
    - 설정 바꿔본다던가 등..

### 위험 편향

- 인간의 본성에 따른 편향
    - 예전에 뭐 바꿨더니 잘못됐던 경험해서 위험감수를 안함
    - 미리 계산된 위험을 조금만 안고 가면 제품을 내놓을 수 있는데 이런 성향땜에 도입을 안함
    - 단위 테스트와 운영계 회귀 테스트 체계만 있으면 이러한 리스크를 줄일 수 있음

### 엘스버그 역설

- 통에 빨간, 파란, 녹색 공이 90개 있는데 파란색은 30개, 빨강 + 녹색은 합쳐서 60개가 있다고 하면 첫번째 내기로
    1. 통에서 꺼낸 공이 파란공이면 승리
    2. 통에서 꺼낸 공이 빨간공이면 승리
- 하는 내기에서 사람들은 1번을 선택하여 1/3 확률을 택함
- 그리고 같은 상자에서 다음 내기를 고름
    1. 통에서 꺼낸 공이 파란 + 녹색이면 승리
    2. 통에서 꺼낸 공이 빨강 + 녹색이면 승리
- 그러면 사람들은 2번을 고름 왜? 2/3 확률이니까
- 그러나 이건 이성적으로 생각하면 이상한 일임
    - 왜? 첫번째 내기에서 파란공을 골랐던것은 빨간공이 30개보다 작고 녹색이 더 많다고 생각했기 때문인데
    - 두번째 내기에서 같은 공수를 공유하는데 첫번째 가정과 다른 2번을 택하는건 논리적이지 않음을 설명하는 것
- 즉 사람들은 불확실한 것 보다 확실한 것을 추구하려는 욕심이 강함.

## 결론

- 우리는 데이터를 적절한 방법으로 처리하고, 비과학적이고 주관적인 사고에 빠지지 않도록 조심해야함
- 그러려면 테스트 유형과 테스트 베스트 프랙티스 사례, 안티패턴을 알아야한다.