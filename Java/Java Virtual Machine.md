![image](https://github.com/user-attachments/assets/e5f09fac-a94a-4374-be44-19eaf6ee33d4)


# 자바는 진화하고 있다
- 예전 조언들이 지금이랑 맞지 않는 경우가 많음 (버전에 따른 성능 증가)
- JVM의 자동 인라이닝은 메서드 디스패치 성능을 엄청나게 좋아지게 함
- 오래전 작성한 자바 코드도 재컴파일 없이 최신 JVM에서 구현하면 더 빨리 작동 가능
- 정량적, 검증 가능한 방식으로 성능을 다뤄야한다.

모든 최적화 기법에는 개발자가 사용하기 전에 알아야하는 함정과 트레이드오프가 존재

> "자바는 블루 칼라 언어이다. 일을 하려고 만든 언어이죠."
> 자바 창시자, 제임스 고슬링

```JVM - 스택 기반의 해석 머신```

평가 스택을 이용해 중간값을 담아두고 가장 마지막에 실행된 명령어와 opcode를 순서대로 처리함

## 어플리케이션 실행시
- OS가 가상 머신 프로세스(JAVA 바이너리) 구동
- 자바 가상환경 구축되고 스택 머신 초기화
- 클래스 파일 실행
- ```public static void main(String args[])``` 이 진입점
유저 클래스의 main메서드를 실행하려면 JVM이 실행되기 전에 진입점이 있는 클래스를 로딩해야 된다.

![image](https://github.com/user-attachments/assets/4fa292e5-f05f-487c-ab81-4bcb5231abb1)

# 자바 클래스로딩 메커니즘 (클래스 로더도 하나의 객체이다.)
- 클래스 로더들이 체이닝되어 차례차례 동작한다.
1. 부트스트랩 클래스 → 런타임 코어클래스 로드 - 다른 클래스로더가 잘 로드할 수 있게 최소한의 필수 클래스(java.lang.Object, Class, ClassLoader) 만 로드
2. 런타임 코어클래스 → rt.jar(JAVA8) 9부터는 다르게
3. 확장 클래스 로더 : 부트스트랩 클래스로더를 부모로 설정하고 필요할때마다 클래스로딩 작업을 이관
    1. 네이티브 코드 제공, 기본 환경 오버라이드 가능
    2. 자바스크립트 런타임 내시혼(Nashorn)을 확장클래스 로더가 로드하는 거임(JAVA 8 부터)
4. 애플리케이션 클래스 로더 : 지정된 클래스패스의 유저 클래스를 로드
- 클래스를 찾지 못한 클래스 로더는 부모 클래스로더 에게 물어봄 (디펜던시 등)
- 계속 거슬러올라가다가 부트스트랩까지 모르면 ClassNotFoundException이 떨어진다.

## 바이트 코드 실행
- 실행되기까지 많은 변환을 거침
- javac(자바 컴파일러)로 소스코드 컴파일하여 바이트 코드로 변환
    - 자바 소스코드를 .class파일로 바꿈
    - 최적화를 거의 안해서 역엔지니어링이 쉬움 javap과 같은 역어셈블리툴로 분석 가능
- 바이트코드는 특정 컴퓨터 아키텍처에 의존하지 않는 중간 표현형(IR)이다.
    - 아키텍쳐의 지배를 받지 않아 이식성이 좋음
    - JVM지원 플랫폼 어디서든 실행 가능
    - 자바 언어에 대해서도 추상화 되어있음!!
        - JVM규격에 맞는 클래스 파일로 컴파일되는 언어들이면 다 정상 실행됨!(kotlin, scala 등)
- 클래스 파일은 VM명세서에 명확히 정의된 구조를 갖고 있음.
    - 모든 클래스 파일은 0xCAFEBABE 로 시작함(4바이트, 16진수)
    - 다음 4바이트는 클래스 파일의 메이저/마이너 버전
        - JVM 컴파일 버전, 클래스 로더 호환성 보장하기 위해서
        - 호환되지 않는 클래스 파일만나면 UnsupportedClassVersionError가 떨어짐
    - 상수 풀(Constant Pool)
        - 클래스 상수들이 모여있는 위치
        - 코드 곳곳에 등장하는 상숫값 (클래스명, 인터페이스명, 필드명 등)이 저장되어 있고,
        - 코드 실행할때 메모리 대신 여기서 참조해서 탐색시간을 아낌.
    - 엑세스 플래그
        - 클래스에 적용한 수정자를 결정
        - public인지 프라이빗인지..
        - 그담은 상속안되는 final로 선언되었는지
        - 인터페이스인지 추상인지
        - 끝으로 소스코드에 없는 합성 클래스인지, 이넘인지, 어노테이션인지를 나타냄
    - this 클래스
    - super 클래스
    - 인터페이스
        - 클래스가 구현한 모든 인터페이스
        - 타입 계층을 나타내고 상수 풀을 가르키는 인덱스로 표시됨.
    - 필드
    - 메서드
        - 시그니쳐들 저장, 수정자도 포함
    - 속성
        - 복잡하고 크기가 고정되지 않는 구조를 표기

## 클래스 생성자도 바이트 코드로 변환됨
- ```aload_0```으로 this(자신)을 스택 최상단에 올리고
- ```invokespecial #1``` 로 super생성자들을 호출
- 인스턴스 메서드에서 0번째 엔트리는 무조건 this, 지역변수 할당은 offset 1부터 저장됨
- ```iload_1``` (1번째 스택값 로드)
- ```iinc 1, 1``` - 정수값 1 증가

![image](https://github.com/user-attachments/assets/d11d39e9-30b8-416b-9d8b-68a4e30946d7)

# 핫스팟입문
1999년 4월에 자바의 요체인 핫스팟 가상머신의 등장 (썬 마이크로시스템즈)
C/C++과 필적한 성능을 자랑했음
- 비야네 스트롭스트룹
- 제로 오버헤드 원칙을 준수
- AOT(Ahead-Of-Time) 사전 컴파일
- 플랫폼에서만 사용가능한 기계어로 번역됨.

### 핫스팟은 런타임 동작을 분석하고 성능에 유리한 방향으로 최적화를 적용하는 가상머신이다
```클래스 로더 → 메서드 캐시 → JIT컴파일러가 실행 최적화 → 코드 캐시 → 인터프리터 → 프로파일러 → 에미터```

![image](https://github.com/user-attachments/assets/12710b3d-52f5-4f8f-a684-c9ff622dea22)

## JIT 컴파일이란?
자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작
CPU를 추상화한 구조라 다른 플랫폼에서도 실행할 수 있지만 최대의 성능은 네이티브 기능을 활용해 CPU에서 직접 실행해야함.
핫스팟은 프로그램 단위(메서드와 루프)를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일

### 이게 바로 JIT(Just-in-Time) 컴파일 기술이다.
인터프리트 모드로 실행하는 동안 애플리케이션을 모니터링
- 가장 자주 실행하는 코드 파트를 발견해 JIT컴파일 수행
- 미리 프로그래밍한 추적정보가 취합되며 더 정교하게 최적화 가능
- 특정 메서드가 임계점을 넘어가면 프로파일러가 특정코드 섹션을 컴파일/최적화 함

### 컴파일러가 해석 단계에서 수집한 추적 정보를 기반으로 최적화를 결정하여 상황별로 수집한 정보를 토대로 더 올바른 방향으로 최적화 가능
새버전이 나올때마다 최적화 기법과 혜택을 추가해 왔기 때문에 핫스팟 새버전일수록 성능이 좋음.

### 주의사항 : 소스코드 → 바이트코드 → JIT 컴파일을 거쳐서 실제로 실행되는 코드는 원본 소스코드와 완전 다를 가능성이 큼.
프로필 기반 최적화(Profile-guided Optimization)은 런타임 정보를 활용할 여지가 있어서 동적 인라이닝, 가상 호출로 성능 개선 가능.
핫스팟 VM은 시동시 CPU타입을 정확히 감지하여 특정 프로세서의 기능에 맞게 최적화를 적용
- 프로세서 기능을 정밀하게 감지하는 기법을 JVM인트린직(내장함수) 라고 함.

핫스팟 VM은 정교하고 실행하며 최적화를 진행하기 때문에, 개발자가 애플리케이션이 실제 동작하는 방식을 단순하게 넘겨짚으면 안된다.

## JVM 메모리 관리
자바를 독보적으로 만들었던 특징 중 하나
C, C++, Objective-C는 메모리 할당/해제를 직접 수행하고, 객체를 생성/삭제와 직접 결부시킬 수 있지만 메모리를 개발자가 정확하게 계산하고 처리해야하는 막중한 책임이 따름
- 메모리 관리 용어조차 모르는 개발자가 많아서.. 문제가 되었음
- 스마트 포인터(unique_ptr, shared_ptr, weak_ptr)을 도입하여서 메모리 자동 해제해주는 기능이 C++11부터 추가되어서 어느정도 해결

### 자바는 GC가 메모리를 관리
- Garbage Collection 프로세스가 힙메모리를 자동 관리
- JVM이 더 많은 메모리를 할당해야 할때 불필요한 메모리를 회수하거나 재사용
- GC가 구동되는 동안은 애플리케이션이 중단되고 하던일 멈춰야함
    - 중단 시간은 대게 아주 짧지만 애플리케이션 부하가 늘수록 무시할 수 없는 수준이 된다.

## 스레딩과 자바 메모리 모델(JMM)
자바 1.0부터 멀티스레드 프로그래밍 지원함
자바 환경 자체가 JVM처럼 멀티 스레드 기반이라 성능분석이나 작동 방식이 복잡해졌다.
자바 애플리케이션 스레드는 각각 정확히 하나의 전용 OS 스레드에 대응된다.
- 공유 스레드 풀을 사용하는 경우도 있지만, 만족할만한 수준의 성능은 안나옴(복잡도가 증가..)

### 자바의 멀티스레드 방식은 3가지 기본 설계 원칙에 기반
1. 자바 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공용 힙을 가진다.
2. 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있다.
3. 기본적으로 객체는 변경 가능하다. 즉 객체 필드에 할당된 값은 프로그래머가 애써 Final 키워드로 표시하지 않는 한 바뀔 수 있다.

JMM은 서로 다른 실행 스레드가 객체 안에 변경되는 값을 어떻게 바라보는지를 기술한 공식 메모리 모델

## JVM구현체 종류
오라클이 제작한 핫스팟 이외에도 제각기 다른 방법으로 구현한 자바 구현체들이 많다.

![image](https://github.com/user-attachments/assets/d6d0c981-7969-4281-b647-4963d7d7683f)

1. OpenJDK
자바 기준 구현체를 제공하는 오픈소스(GPL) 프로젝트
오라클이 프로젝트 주관, 지원하며 자바 릴리즈 기준이 됨.
2. Oracle
OpenJDK기준, 가장 널리 알려짐, 오라클 상용 라이선스
3. Zulu
아줄 시스템이 제작함, 자바 풀 인증을 받은 무료 OpenJDK 기반
4. IcedTea
레드햇이 제작, 풀 인증, 재배포 가능, OpenJDK 기반
5. Zing
아줄 시스템, 고성능 상용 JVM, 풀인증, 64비트 리눅스에서만 작동, 대용량 힙메모리, 멀티 CPU서버급 시스템을 위한 것
6. J9
IBM이 만듦, 상용이었지만 중간에 오픈소스로 전환, 이클립스 OMR 프로젝트 기반
7. Avian
100% 자바 인증을 받진 않음, JVM의 세부 작동 원리가 궁금하면 훌륭한 학습 도구역할을 함
8. Android
논JVM 가상 머신 용도의 다른 파일 포맷(.dex)으로 변환하기 위해 여러 자바 클래스 라이브러리 구현체와 교차 컴파일러를 사용
자체 런타임에서 직접 지원되는 OpenJDK 8 클래스 라이브러리를 사용함

## JVM모니터링과 툴링
JVM은 
- Instrumentation (오류 진단이나 성능 개선을 위해 애플리케이션에 특정한 코드를 끼워 넣는 것)
- 모니터링
- 관측
을 위한 다양한 기술 제공

![image](https://github.com/user-attachments/assets/5340bd7a-cb0c-4111-a233-235d2ed63e53)

### 자바 관리 확장(JMX)
  - Java Management Extentions
  - JVM과 그 위에서 동작하는 애플리케이션 제어하고 모니터링
  - 메서드 호출 및 매개변수 설정 가능
  - JVM을 관리하는 기본 수단
### 자바 에이전트
  - 자바 언어로 작성된 툴 컴포넌트
  - java.lang.instrument 인터페이스로 바이트 코드 조작
  - JVM에 시작 플래스를 추가해 설치
  - -javaagent:<Jar경로>=<옵션>
  - manifest.mf 파일 필수
  - Premain-Class 속성에 에이전트 클래스명 지정 필수
      - 해당 클래스는 public static premain()메서드 구현해야하고, 후킹을 수행
### JVM 툴 인터페이스(JVMTI)
  - JVMTI는 네이티브 인터페이스
  - C/C++같은 네이티브 컴파일 언어로 작성해야함
      - 네이티브 코드로 개발해야 되기 때문에 애플리케이션에 악영향을 미치는 코드를 짜기 쉬움 (감지도 불가)
  - 에이전트가 JVM이벤트 모니터링하여 알람을 받을 수 있도록 만든 통신 인터페이스
  - -agentlib:<에이전트 라이브러리명/경로>=<옵션>
### 서비서빌리티 에이전트(SA)
  - Serviceability Agent
  - 자바 객체, 핫스팟 자료 구조, 표출 가능한 API와 툴을 모아놓은 것.
  - SA를 사용하면 JVM에서 코드를 실행할 필요가 없음
  - 핫스팟 SA는 심볼 룩업 같은 기본형을 이용하거나 프로세스 메모리를 읽어 디버깅함.
  - 코어파일(크래시 덤프 파일) 및 생생한 자바 프로세스까지 디버깅 가능

### VisualVM
- 넷빈즈 플랫폼 기반의 시각화 툴
- jconsole 대체제, 상위호환
- 따로 바이너리 파일 받아야함
- 프로세스가 로컬인지 원격인지에 따라 작동 방식이 다름
- 제공하는 정보
  - 개요(프로세스에 대한 요약 정보)
  - 모니터(CPU, 힙사용량 등)
  - 쓰레드 (쓰레드 덤프 뜰수 있음)
  - 샘플러 및 프로파일러(CPU 및 메모리 사용률에 관한 단순 샘플링)
